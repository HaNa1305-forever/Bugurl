<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>GPU Stress Test Demo MAX</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background: #000;
      height: 100%; width: 100%;
    }
    canvas {
      display: block;
      width: 100vw; height: 100vh;
    }
  </style>
</head>
<body>
<canvas id="glcanvas" width="1536" height="1536"></canvas>
<script>
  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

  if (!gl) {
    alert('WebGL not supported');
  }

  const vertexShaderSource = `
    attribute vec3 position;
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  `;

  const fragmentShaderSource = `
    precision highp float;

    uniform float time;
    uniform vec2 resolution;

    mat2 rot(float a) {
      float c = cos(a), s = sin(a);
      return mat2(c, -s, s, c);
    }

    float hash(vec2 p) {
      return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123);
    }

    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      vec2 u = f*f*(3.0 - 2.0*f);
      return mix(a, b, u.x) +
             (c - a)* u.y * (1.0 - u.x) +
             (d - b) * u.x * u.y;
    }

    float fbm(vec2 p) {
      float f = 0.0;
      float w = 0.5;
      for (int i=0; i<6; i++) {
        f += w * noise(p);
        p *= 2.0;
        w *= 0.5;
      }
      return f;
    }

    float fractal(vec2 uv) {
      float sum = 0.0;
      float scale = 1.0;
      vec2 pos = uv;
      for (int i=0; i < 100; i++) {
        pos = abs(pos) / dot(pos, pos) - 1.5;
        sum += abs(fbm(pos * scale));
        scale *= 1.5;
      }
      return sum;
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;
      uv *= 1.5;
      uv = rot(time * 0.2) * uv;

      float zoom = 1.0 + 0.6 * sin(time * 3.0);
      uv *= zoom;

      float f = fractal(uv * 2.0);
      vec3 col = vec3(0.5 + 0.5 * sin(time + f * 10.0), 
                      0.5 + 0.5 * cos(time + f * 5.0), 
                      f * 0.7);

      float n = noise(gl_FragCoord.xy * 0.1 + vec2(time * 5.0));
      col += vec3(n * 0.2);

      gl_FragColor = vec4(col, 1.0);
    }
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert('Shader compile error: ' + gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    alert('Program link error: ' + gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);

  const positionLocation = gl.getAttribLocation(program, 'position');
  const resolutionLocation = gl.getUniformLocation(program, 'resolution');
  const timeLocation = gl.getUniformLocation(program, 'time');

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  const positions = new Float32Array([
    -1, -1, 0,
    1, -1, 0,
    -1, 1, 0,
    1, 1, 0
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

  function render(time) {
    time *= 0.001;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
    gl.uniform1f(timeLocation, time);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
</script>
</body>
</html>
